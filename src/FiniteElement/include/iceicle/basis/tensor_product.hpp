/**
 * @brief generalized interfaces for tensor products of basis functions
 * @author Gianni Absillis (gabsill@ncsu.edu)
 */
#pragma once

#include "Numtool/integer_utils.hpp"
#include "Numtool/fixed_size_tensor.hpp"
#include "Numtool/tmp_flow_control.hpp"
namespace BASIS {

    /**
     * @brief a Q-Type tensor product 
     * The classical outer product tensor product 
     * @tparam T the floating point type
     * @tparam ndim the number of dimensions
     * @tparam nbasis_1d the number of basis functions for the 1D basis function
     */
    template<class T, int ndim, int nbasis_1d>
    struct QTypeProduct {
        template<typename T1, std::size_t... sizes>
        using Tensor = NUMTOOL::TENSOR::FIXED_SIZE::Tensor<T1, sizes...>;

        /// The total number of entries generated by the tensor product
        static constexpr int nvalues = MATH::power_T<nbasis_1d, ndim>::value;


        /// The distance in 1d indices between subsequent ijk (dimensional) indices 
        static constexpr NUMTOOL::TENSOR::FIXED_SIZE::Tensor<int, ndim> strides = []{
            NUMTOOL::TENSOR::FIXED_SIZE::Tensor<int, ndim> ret{};
            NUMTOOL::TMP::constexpr_for_range<0, ndim>([&]<int i>{
                ret[i] = MATH::power_T<nbasis_1d, ndim - i - 1>::value;
            });
            return ret;
        }();

        /// @brief convert an ijk (dimensional) index to a 1d index
        static constexpr int convert_ijk(int ijk[ndim]) {
            int ret = 0;
            for(int idim = 0; idim < ndim; ++idim){
                ret += ijk[idim] * std::pow(nbasis_1d, ndim - idim - 1);
            }
            return ret;
        }
    };
}
